[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Quarto Website",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "Python.html",
    "href": "Python.html",
    "title": "Python",
    "section": "",
    "text": "Information about Python"
  },
  {
    "objectID": "python.html",
    "href": "python.html",
    "title": "Python",
    "section": "",
    "text": "Information about Python"
  },
  {
    "objectID": "neuralNetworks.html",
    "href": "neuralNetworks.html",
    "title": "Neural Networks",
    "section": "",
    "text": "Introduction to Neural Networks"
  },
  {
    "objectID": "Proyecto_HeadCounting.html",
    "href": "Proyecto_HeadCounting.html",
    "title": "Librerias",
    "section": "",
    "text": "!pip install --upgrade tensorflow\n!pip install timm\nimport tensorflow as tf\nimport pandas as pd\nimport numpy as np\nimport os\nimport concurrent.futures\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom PIL import Image\nimport glob\nimport scipy.io\n\nfrom google.colab import drive\n\nfrom tensorflow.keras.preprocessing.image import load_img, img_to_array\nfrom keras.layers import Conv2D, MaxPooling2D, Dropout, Flatten, Dense, BatchNormalization\nfrom keras.optimizers import Adam\nfrom keras.callbacks import EarlyStopping\n\nfrom sklearn.model_selection import train_test_split"
  },
  {
    "objectID": "Proyecto_HeadCounting.html#imagenes-de-grupos",
    "href": "Proyecto_HeadCounting.html#imagenes-de-grupos",
    "title": "Librerias",
    "section": "Imagenes de grupos",
    "text": "Imagenes de grupos\n\ndef cantidad_personas(lista):\n    personas = 0\n    for elem in lista:\n        if elem.get('label')=='person':\n            personas += 1\n    return personas\n\ndef imprimir_objetos(img, lista):\n    plt.imshow(img.values[0])\n    for elem in lista:\n        if elem.get('label')=='person':\n            width = elem['box']['xmax'] - elem['box']['xmin']\n            height = elem['box']['ymax'] - elem['box']['ymin']\n            rect = patches.Rectangle((elem['box']['xmin'], elem['box']['ymin']), width, height, linewidth=5, edgecolor='r', facecolor='none')\n\n            plt.gca().add_patch(rect)\n\n    plt.title(f'Cantidad de personas: {cantidad_personas(lista)}', fontsize=60)\n    plt.axis('off')\n\ndef array_to_image(array):\n    return Image.fromarray((array * 255).astype('uint8'))\n\n\nrandom = df.sample(1)\nimagen_array = random['imagen'].values[0]\nimagen_pil = array_to_image(imagen_array)\n\nev_modelo = model(imagen_pil)\n\ncantidad = cantidad_personas(ev_modelo)\n\nprint(f\"Cantidad de personas: {cantidad}\")\n\nprint(ev_modelo)\n\nplt.figure(figsize=(25, 25))\nimprimir_objetos(random['imagen'], ev_modelo)\n\n\ndef imprimir_objetos_multiple(img, lista):\n    plt.imshow(img)\n    for elem in lista:\n        if elem.get('label')=='person':\n            width = elem['box']['xmax'] - elem['box']['xmin']\n            height = elem['box']['ymax'] - elem['box']['ymin']\n            rect = patches.Rectangle((elem['box']['xmin'], elem['box']['ymin']), width, height, linewidth=0.5, edgecolor='r', facecolor='none')\n\n            plt.gca().add_patch(rect)\n\n    plt.title(f'Cantidad de personas: {cantidad_personas(lista)}')\n    plt.axis('off')\n\n\n# Ahora lo pruebo con diversas imagenes del df\nrandom = df.sample(9)\n\nplt.figure(figsize=(10, 10))\nfor i, (_, row) in enumerate(random.iterrows()):\n    ax = plt.subplot(3, 3, i + 1)\n    imagen_array = row['imagen']\n    imagen_pil = array_to_image(imagen_array)\n    ev_modelo = model(imagen_pil)\n    imprimir_objetos_multiple(row['imagen'], ev_modelo)\n\nAl ser un modelo que detecta objetos en algunos momentos puede generar algunos errores pero en general parece funcionar de forma bastante correcta"
  },
  {
    "objectID": "Proyecto_HeadCounting.html#imagenes-de-multitudes",
    "href": "Proyecto_HeadCounting.html#imagenes-de-multitudes",
    "title": "Librerias",
    "section": "Imagenes de multitudes",
    "text": "Imagenes de multitudes\nAhora lo voy a poner a prueba con imagenes de multitudes obtenidas originalmente de kaggle del dataset ShangaiTech https://www.kaggle.com/datasets/tthien/shanghaitech\n\n#Importo algunas imagenes de multitudes\ndf_crowd = tf.keras.utils.image_dataset_from_directory('/content/gdrive/MyDrive/Colab Notebooks/ProyectoFinal/Crowd Counting/shanghaitech_with_people_density_map/ShanghaiTech/part_A/train_data/images/', shuffle=False)\n\nFound 300 files belonging to 1 classes.\n\n\n\n#La información de la cantidad de personas que se encuentra en cada foto esta almacenada en archivos .mat\n\n# Patrón para seleccionar todos los archivos .mat en el directorio\nmat_files = glob.glob(os.path.join('/content/gdrive/MyDrive/Colab Notebooks/ProyectoFinal/Crowd Counting/shanghaitech_with_people_density_map/ShanghaiTech/part_A/train_data/ground-truth', '*.mat'))\n\n# Ordenar la lista de archivos\nmat_files_sorted = sorted(mat_files)\n\n# Lista para almacenar los datos cargados\ndata_list = []\n\n# Iterar sobre los archivos .mat de train y cargarlos\nfor mat_file in mat_files_sorted:\n    mat_data = scipy.io.loadmat(mat_file)\n    data_list.append(mat_data)\n\n\nimage_info_df = []\nfor data in data_list:\n    image_info = data[\"image_info\"]\n    image_info_df.append(image_info)\n\n\nnumber_list = np. array([])\nfor image in image_info_df:\n    number_array = image[0,0][0][0][1]\n    number = number_array[0][0]\n    number_list = np.append(number_list, number)\nnumber_list = number_list.astype(int)\n\n\n# Se muestran algunas imagenes con la cantidad de personas que la componen\nplt.figure(figsize=(7, 7))\nfor images, labels in df_crowd.take(1):\n    for i in range(9):\n        ax = plt.subplot(3, 3, i + 1)\n        plt.imshow(images[i].numpy().astype('uint8'))\n        plt.title(number_list[i])\n        plt.axis('off')\n\nPara poder utilizar las funciones ya definidas tengo que transformar al mismo formato de df las imagenes de multitudes\n\n# Con esto df_crowd_pd es un DataFrame de pandas con una columna 'imagen' que contiene arrays de NumPy\n# y una columna 'HeadCount' que contiene las etiquetas correspondientes\n\nimagenes = []\n\nfor imagenes_batch, etiquetas_batch in df_crowd:\n    imagenes.extend(imagenes_batch.numpy())\n\ndf_crowd_pd = pd.DataFrame({'imagen': imagenes})\n\ndf_crowd_pd['HeadCount'] = pd.DataFrame(number_list) #La información de la cantidad de personas ya la tengo de number_list\n\n\ndf_crowd_pd.head()\n\n\n  \n    \n\n\n\n\n\n\nimagen\nHeadCount\n\n\n\n\n0\n[[[251.0, 250.0, 254.0], [207.0, 206.0, 211.5]...\n1546\n\n\n1\n[[[44.416992, 58.918945, 68.418945], [78.64258...\n920\n\n\n2\n[[[251.0, 253.0, 252.0], [241.5, 245.5, 246.5]...\n371\n\n\n3\n[[[39.0, 52.0, 34.0], [35.5, 48.5, 30.5], [43....\n298\n\n\n4\n[[[130.5, 104.5, 115.5], [136.5, 110.5, 121.5]...\n184\n\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n# Se enseñan 9 imagenes al azar para verificar el correcto funcionamiento del dataframe\nrandom = df_crowd_pd.sample(9)\n\nrandom['imagen'] = random['imagen'] / 255.0\n\nplt.figure(figsize=(10, 10))\nfor i, (_, row) in enumerate(random.iterrows()):\n    ax = plt.subplot(3, 3, i + 1)\n    plt.imshow(row['imagen'])\n    plt.title(row['HeadCount'])\n    plt.suptitle('Imagenes aleatorias')\n    plt.axis('off')\n\n\ndef imprimir_multitud_multiple(data, lista):\n    img = data['imagen']\n    plt.imshow(img)\n    for elem in lista:\n        if elem.get('label')=='person':\n            width = elem['box']['xmax'] - elem['box']['xmin']\n            height = elem['box']['ymax'] - elem['box']['ymin']\n            rect = patches.Rectangle((elem['box']['xmin'], elem['box']['ymin']), width, height, linewidth=0.5, edgecolor='r', facecolor='none')\n\n            plt.gca().add_patch(rect)\n\n    title = f'Cantidad de personas calculada: {cantidad_personas(lista)}\\n'\n    title += f'Cantidad de personas real: {data[\"HeadCount\"]}'\n    plt.title(title, fontsize=10)\n    plt.axis('off')\n\n\nrandom = df_crowd_pd.sample(9)\n\nrandom['imagen'] = random['imagen'] / 255.0\n\nplt.figure(figsize=(10, 10))\nfor i, (_, row) in enumerate(random.iterrows()):\n    ax = plt.subplot(3, 3, i + 1)\n    imagen_array = row['imagen']\n    imagen_pil = array_to_image(imagen_array)\n    ev_modelo = model(imagen_pil)\n    imprimir_multitud_multiple(row, ev_modelo)\n\nComo se puede ver el resultado obtenido no es el esperado. Para intentar mejorarlo se va a proceder a dividir una imagen en varios trozos y a evaluar uno por uno\n\ndef dividir_imagen(img, size=(50, 50)):\n    # Obtiene el tamaño de la imagen\n    width, height = img.size\n\n    # Tamaño de los trozos\n    trozo_width, trozo_height = size\n\n    # Calcula la cantidad de trozos a lo largo de x e y\n    trozos_x = width // trozo_width\n    trozos_y = height // trozo_height\n\n    # Lista para almacenar los trozos\n    trozos = []\n\n    # Itera sobre los trozos y agrégalos a la lista\n    for j in range(trozos_y):\n        for i in range(trozos_x):\n            xmin, ymin = i * trozo_width, j * trozo_height\n            xmax, ymax = xmin + trozo_width, ymin + trozo_height\n            trozo = img.crop((xmin, ymin, xmax, ymax))\n            trozos.append(trozo)\n\n    return trozos\n\n\n# Para hacer esta prueba selecciono una imagen en especifico en onde se identifiquen claramente las caras de las personas\n\n# Imagen que se desea dividir\nimagen_crowd = Image.fromarray(df_crowd_pd['imagen'][5].astype('uint8'))\n\n# Tamaño de los trozos\ntamaño_trozos = (50, 50)\n\n# Obtiene los trozos de la imagen\ntrozos = dividir_imagen(imagen_crowd, tamaño_trozos)\n\n# Muestra cada trozo individualmente\nfor i, trozo in enumerate(trozos):\n    trozo.show()\n\n\nfilas = int(np.ceil(np.sqrt(len(trozos))))\ncolumnas = int(np.ceil(len(trozos) / filas))\n\n# Muestra todos los trozos en una sola imagen\nplt.figure(figsize=(10, 10))\n\nfor i, trozo in enumerate(trozos, 1):\n    plt.subplot(filas, columnas, i)\n    plt.imshow(np.array(trozo))\n    plt.axis('off')\n\nplt.show()\n\n\nimagen_crowd\n\n\n\n\n\n# Ahora aplico el modelo a cada trozo y se muestra el conteo de las personas localizadas\n\nfilas = int(np.ceil(np.sqrt(len(trozos))))\ncolumnas = int(np.ceil(len(trozos) / filas))\n\nplt.figure(figsize=(15, 15))\nfor i, trozo in enumerate(trozos, 1):\n    ax = plt.subplot(filas, columnas, i)\n    ev_modelo = model(trozo)\n    imprimir_objetos_multiple(trozo, ev_modelo)\n\nComo se puede apreciar no ha sido detectada ninguna persona. El problema puede venir de la calidad de la imagen. Para reducir el consumo de memoria las imagenes se importaron de forma automatica, sin especificar el tamaño, por lo que fueron reducidas a 256x256\nSe va a volver a realizar la prueba con otra foto de mayor calidad, tanto descargandola en 256x256 como en su resolución real\n\n# Imagen que se desea dividir\nimagen_crowd = Image.fromarray(df_crowd_pd['imagen'][7].astype('uint8'))\npersonas_real = number_list[7]\n\n# Tamaño de los trozos\ntamaño_trozos = (50, 50)\n\n# Obtiene los trozos de la imagen\ntrozos = dividir_imagen(imagen_crowd, tamaño_trozos)\n\n# Muestra cada trozo individualmente\nfor i, trozo in enumerate(trozos):\n    trozo.show()\n\n\nfilas = int(np.ceil(np.sqrt(len(trozos))))\ncolumnas = int(np.ceil(len(trozos) / filas))\n\n# Muestra todos los trozos en una sola imagen\nplt.figure(figsize=(10, 10))\n\nfor i, trozo in enumerate(trozos, 1):\n    plt.subplot(filas, columnas, i)\n    plt.imshow(np.array(trozo))\n    plt.axis('off')\n\nplt.show()\n\n\nimagen_crowd\n\n\n\n\n\nfilas = int(np.ceil(np.sqrt(len(trozos))))\ncolumnas = int(np.ceil(len(trozos) / filas))\n\npersonas_foto = 0\n\nplt.figure(figsize=(15, 15))\nfor i, trozo in enumerate(trozos, 1):\n    ax = plt.subplot(filas, columnas, i)\n    ev_modelo = model(trozo)\n    imprimir_objetos_multiple(trozo, ev_modelo)\n    personas_foto = personas_foto + cantidad_personas(ev_modelo)\n\nprint(f'El total calculado de personas en la imagen es: {personas_foto}')\nprint(f'El total real de personas en la imagen es: {personas_real}')\n\n\nimagen_tf = tf.keras.preprocessing.image.load_img('/content/gdrive/MyDrive/Colab Notebooks/ProyectoFinal/Crowd Counting/shanghaitech_with_people_density_map/ShanghaiTech/part_A/train_data/images/Crowd/IMG_105.jpg')\n\n\nimagen_np = tf.keras.preprocessing.image.img_to_array(imagen_tf)\n\n\n# Imagen que se desea dividir\nimagen_crowd = Image.fromarray(imagen_np.astype('uint8'))\nprint(imagen_crowd.size)\npersonas_real = number_list[7]\n\n# Tamaño de los trozos\ntamaño_trozos = (200, 200)\n\n# Obtiene los trozos de la imagen\ntrozos = dividir_imagen(imagen_crowd, tamaño_trozos)\n\n# Muestra cada trozo individualmente\nfor i, trozo in enumerate(trozos):\n    trozo.show()\n\n(990, 632)\n\n\n\nfilas = int(np.ceil(np.sqrt(len(trozos))))\ncolumnas = int(np.ceil(len(trozos) / filas))\n\npersonas_foto = 0\n\nplt.figure(figsize=(15,15))\nfor i, trozo in enumerate(trozos, 1):\n    ax = plt.subplot(3, 4, i)\n    ev_modelo = model(trozo)\n    imprimir_objetos_multiple(trozo, ev_modelo)\n    personas_foto = personas_foto + cantidad_personas(ev_modelo)\n\nprint(f'El total calculado de personas en la imagen es: {personas_foto}')\nprint(f'El total real de personas en la imagen es: {personas_real}')\n\n\n# Imagen que se desea dividir\nimagen_crowd = Image.fromarray(imagen_np.astype('uint8'))\nprint(imagen_crowd.size)\npersonas_real = number_list[7]\n\n# Tamaño de los trozos\ntamaño_trozos = (330, 126)\n\n# Obtiene los trozos de la imagen\ntrozos = dividir_imagen(imagen_crowd, tamaño_trozos)\n\n# Muestra cada trozo individualmente\nfor i, trozo in enumerate(trozos):\n    trozo.show()\n\n(990, 632)\n\n\n\nfilas = int(np.ceil(np.sqrt(len(trozos))))\ncolumnas = int(np.ceil(len(trozos) / filas))\n\npersonas_foto = 0\n\nplt.figure(figsize=(15,15))\nfor i, trozo in enumerate(trozos, 1):\n    ax = plt.subplot(5, 3, i)\n    ev_modelo = model(trozo)\n    imprimir_objetos_multiple(trozo, ev_modelo)\n    personas_foto = personas_foto + cantidad_personas(ev_modelo)\n\nprint(f'El total calculado de personas en la imagen es: {personas_foto}')\nprint(f'El total real de personas en la imagen es: {personas_real}')\n\nCon mejor resolución el resultado mejora considerablemente. Queda faltando entrenar el modulo con un dataset unicamente compuesto por personas, seguramente los resultados serian mucho mejores"
  }
]