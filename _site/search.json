[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Quarto Website",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\nEsto es hacer una prueba"
  },
  {
    "objectID": "Python.html",
    "href": "Python.html",
    "title": "Python",
    "section": "",
    "text": "Information about Python"
  },
  {
    "objectID": "python.html",
    "href": "python.html",
    "title": "Python",
    "section": "",
    "text": "Python is a popular and versatile programming language known for its simplicity and readability. Here’s a simple introduction highlighting the key elements to consider when using this programming language:\n\nReadability: Python focuses on code readability, meaning its syntax is clear and easy to understand. This makes it ideal for both beginners and experienced programmers.\nInterpreted: Python is an interpreted language, which means you don’t need to compile your code before running it. This makes writing and testing code easier, as you can see results immediately.\nDocumentation and Comments: Python supports inline comments and docstrings, allowing developers to document their code effectively. Writing clear and concise comments helps explain complex logic, assumptions, and intentions, enhancing readability and maintainability.\nDynamic typing: Python is dynamically typed, so you don’t need to explicitly declare a variable’s type. Python infers the data type during program execution.\n\n# Integer\nx = 10  \n# Output: &lt;class 'int'&gt;\nprint(type(x))  \n\n# String\nx = \"Hello\" \n# Output: &lt;class 'str'&gt; \nprint(type(x))  \n\n# List\nx = [1, 2, 3] \n# Output: &lt;class 'list'&gt; \nprint(type(x))                                           \n\nCross-platform: Python is compatible with various operating systems such as Windows, macOS, and Linux, making it highly portable.\nExtensive standard library: Python comes with an extensive standard library that provides modules and functions for a variety of tasks, from file manipulation to web development and data processing.\nObject-oriented: Python is an object-oriented programming language, meaning everything in Python is an object with properties and methods.\nIndentation: Indentation is the whitespace at the beginning of a line of code. Python uses indentation to delimit code blocks instead of braces or keywords like in other languages. This promotes writing clean and readable code.\n\nif x &gt; 5:\n    print(\"This is a Python code example\")\n    print(\"Great!\")\nelse:\n    print(\"Oh no!\")                                           \n\nActive community: Python has a large community of developers who contribute libraries, tutorials, and helpful resources. This means you can easily find help and access a wealth of educational resources."
  },
  {
    "objectID": "neuralNetworks.html",
    "href": "neuralNetworks.html",
    "title": "Neural Networks",
    "section": "",
    "text": "Introduction to Neural Networks"
  },
  {
    "objectID": "Proyecto_HeadCounting.html",
    "href": "Proyecto_HeadCounting.html",
    "title": "Librerias",
    "section": "",
    "text": "!pip install --upgrade tensorflow\n!pip install timm\nimport tensorflow as tf\nimport pandas as pd\nimport numpy as np\nimport os\nimport concurrent.futures\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom PIL import Image\nimport glob\nimport scipy.io\n\nfrom google.colab import drive\n\nfrom tensorflow.keras.preprocessing.image import load_img, img_to_array\nfrom keras.layers import Conv2D, MaxPooling2D, Dropout, Flatten, Dense, BatchNormalization\nfrom keras.optimizers import Adam\nfrom keras.callbacks import EarlyStopping\n\nfrom sklearn.model_selection import train_test_split"
  },
  {
    "objectID": "Proyecto_HeadCounting.html#imagenes-de-grupos",
    "href": "Proyecto_HeadCounting.html#imagenes-de-grupos",
    "title": "Librerias",
    "section": "Imagenes de grupos",
    "text": "Imagenes de grupos\n\ndef cantidad_personas(lista):\n    personas = 0\n    for elem in lista:\n        if elem.get('label')=='person':\n            personas += 1\n    return personas\n\ndef imprimir_objetos(img, lista):\n    plt.imshow(img.values[0])\n    for elem in lista:\n        if elem.get('label')=='person':\n            width = elem['box']['xmax'] - elem['box']['xmin']\n            height = elem['box']['ymax'] - elem['box']['ymin']\n            rect = patches.Rectangle((elem['box']['xmin'], elem['box']['ymin']), width, height, linewidth=5, edgecolor='r', facecolor='none')\n\n            plt.gca().add_patch(rect)\n\n    plt.title(f'Cantidad de personas: {cantidad_personas(lista)}', fontsize=60)\n    plt.axis('off')\n\ndef array_to_image(array):\n    return Image.fromarray((array * 255).astype('uint8'))\n\n\nrandom = df.sample(1)\nimagen_array = random['imagen'].values[0]\nimagen_pil = array_to_image(imagen_array)\n\nev_modelo = model(imagen_pil)\n\ncantidad = cantidad_personas(ev_modelo)\n\nprint(f\"Cantidad de personas: {cantidad}\")\n\nprint(ev_modelo)\n\nplt.figure(figsize=(25, 25))\nimprimir_objetos(random['imagen'], ev_modelo)\n\n\ndef imprimir_objetos_multiple(img, lista):\n    plt.imshow(img)\n    for elem in lista:\n        if elem.get('label')=='person':\n            width = elem['box']['xmax'] - elem['box']['xmin']\n            height = elem['box']['ymax'] - elem['box']['ymin']\n            rect = patches.Rectangle((elem['box']['xmin'], elem['box']['ymin']), width, height, linewidth=0.5, edgecolor='r', facecolor='none')\n\n            plt.gca().add_patch(rect)\n\n    plt.title(f'Cantidad de personas: {cantidad_personas(lista)}')\n    plt.axis('off')\n\n\n# Ahora lo pruebo con diversas imagenes del df\nrandom = df.sample(9)\n\nplt.figure(figsize=(10, 10))\nfor i, (_, row) in enumerate(random.iterrows()):\n    ax = plt.subplot(3, 3, i + 1)\n    imagen_array = row['imagen']\n    imagen_pil = array_to_image(imagen_array)\n    ev_modelo = model(imagen_pil)\n    imprimir_objetos_multiple(row['imagen'], ev_modelo)\n\nAl ser un modelo que detecta objetos en algunos momentos puede generar algunos errores pero en general parece funcionar de forma bastante correcta"
  },
  {
    "objectID": "Proyecto_HeadCounting.html#imagenes-de-multitudes",
    "href": "Proyecto_HeadCounting.html#imagenes-de-multitudes",
    "title": "Librerias",
    "section": "Imagenes de multitudes",
    "text": "Imagenes de multitudes\nAhora lo voy a poner a prueba con imagenes de multitudes obtenidas originalmente de kaggle del dataset ShangaiTech https://www.kaggle.com/datasets/tthien/shanghaitech\n\n#Importo algunas imagenes de multitudes\ndf_crowd = tf.keras.utils.image_dataset_from_directory('/content/gdrive/MyDrive/Colab Notebooks/ProyectoFinal/Crowd Counting/shanghaitech_with_people_density_map/ShanghaiTech/part_A/train_data/images/', shuffle=False)\n\nFound 300 files belonging to 1 classes.\n\n\n\n#La información de la cantidad de personas que se encuentra en cada foto esta almacenada en archivos .mat\n\n# Patrón para seleccionar todos los archivos .mat en el directorio\nmat_files = glob.glob(os.path.join('/content/gdrive/MyDrive/Colab Notebooks/ProyectoFinal/Crowd Counting/shanghaitech_with_people_density_map/ShanghaiTech/part_A/train_data/ground-truth', '*.mat'))\n\n# Ordenar la lista de archivos\nmat_files_sorted = sorted(mat_files)\n\n# Lista para almacenar los datos cargados\ndata_list = []\n\n# Iterar sobre los archivos .mat de train y cargarlos\nfor mat_file in mat_files_sorted:\n    mat_data = scipy.io.loadmat(mat_file)\n    data_list.append(mat_data)\n\n\nimage_info_df = []\nfor data in data_list:\n    image_info = data[\"image_info\"]\n    image_info_df.append(image_info)\n\n\nnumber_list = np. array([])\nfor image in image_info_df:\n    number_array = image[0,0][0][0][1]\n    number = number_array[0][0]\n    number_list = np.append(number_list, number)\nnumber_list = number_list.astype(int)\n\n\n# Se muestran algunas imagenes con la cantidad de personas que la componen\nplt.figure(figsize=(7, 7))\nfor images, labels in df_crowd.take(1):\n    for i in range(9):\n        ax = plt.subplot(3, 3, i + 1)\n        plt.imshow(images[i].numpy().astype('uint8'))\n        plt.title(number_list[i])\n        plt.axis('off')\n\nPara poder utilizar las funciones ya definidas tengo que transformar al mismo formato de df las imagenes de multitudes\n\n# Con esto df_crowd_pd es un DataFrame de pandas con una columna 'imagen' que contiene arrays de NumPy\n# y una columna 'HeadCount' que contiene las etiquetas correspondientes\n\nimagenes = []\n\nfor imagenes_batch, etiquetas_batch in df_crowd:\n    imagenes.extend(imagenes_batch.numpy())\n\ndf_crowd_pd = pd.DataFrame({'imagen': imagenes})\n\ndf_crowd_pd['HeadCount'] = pd.DataFrame(number_list) #La información de la cantidad de personas ya la tengo de number_list\n\n\ndf_crowd_pd.head()\n\n\n  \n    \n\n\n\n\n\n\nimagen\nHeadCount\n\n\n\n\n0\n[[[251.0, 250.0, 254.0], [207.0, 206.0, 211.5]...\n1546\n\n\n1\n[[[44.416992, 58.918945, 68.418945], [78.64258...\n920\n\n\n2\n[[[251.0, 253.0, 252.0], [241.5, 245.5, 246.5]...\n371\n\n\n3\n[[[39.0, 52.0, 34.0], [35.5, 48.5, 30.5], [43....\n298\n\n\n4\n[[[130.5, 104.5, 115.5], [136.5, 110.5, 121.5]...\n184\n\n\n\n\n\n\n    \n\n  \n    \n\n  \n    \n  \n    \n\n  \n\n    \n  \n\n\n\n  \n\n\n    \n        \n    \n\n  \n\n\n\n  \n\n    \n  \n\n\n\n# Se enseñan 9 imagenes al azar para verificar el correcto funcionamiento del dataframe\nrandom = df_crowd_pd.sample(9)\n\nrandom['imagen'] = random['imagen'] / 255.0\n\nplt.figure(figsize=(10, 10))\nfor i, (_, row) in enumerate(random.iterrows()):\n    ax = plt.subplot(3, 3, i + 1)\n    plt.imshow(row['imagen'])\n    plt.title(row['HeadCount'])\n    plt.suptitle('Imagenes aleatorias')\n    plt.axis('off')\n\n\ndef imprimir_multitud_multiple(data, lista):\n    img = data['imagen']\n    plt.imshow(img)\n    for elem in lista:\n        if elem.get('label')=='person':\n            width = elem['box']['xmax'] - elem['box']['xmin']\n            height = elem['box']['ymax'] - elem['box']['ymin']\n            rect = patches.Rectangle((elem['box']['xmin'], elem['box']['ymin']), width, height, linewidth=0.5, edgecolor='r', facecolor='none')\n\n            plt.gca().add_patch(rect)\n\n    title = f'Cantidad de personas calculada: {cantidad_personas(lista)}\\n'\n    title += f'Cantidad de personas real: {data[\"HeadCount\"]}'\n    plt.title(title, fontsize=10)\n    plt.axis('off')\n\n\nrandom = df_crowd_pd.sample(9)\n\nrandom['imagen'] = random['imagen'] / 255.0\n\nplt.figure(figsize=(10, 10))\nfor i, (_, row) in enumerate(random.iterrows()):\n    ax = plt.subplot(3, 3, i + 1)\n    imagen_array = row['imagen']\n    imagen_pil = array_to_image(imagen_array)\n    ev_modelo = model(imagen_pil)\n    imprimir_multitud_multiple(row, ev_modelo)\n\nComo se puede ver el resultado obtenido no es el esperado. Para intentar mejorarlo se va a proceder a dividir una imagen en varios trozos y a evaluar uno por uno\n\ndef dividir_imagen(img, size=(50, 50)):\n    # Obtiene el tamaño de la imagen\n    width, height = img.size\n\n    # Tamaño de los trozos\n    trozo_width, trozo_height = size\n\n    # Calcula la cantidad de trozos a lo largo de x e y\n    trozos_x = width // trozo_width\n    trozos_y = height // trozo_height\n\n    # Lista para almacenar los trozos\n    trozos = []\n\n    # Itera sobre los trozos y agrégalos a la lista\n    for j in range(trozos_y):\n        for i in range(trozos_x):\n            xmin, ymin = i * trozo_width, j * trozo_height\n            xmax, ymax = xmin + trozo_width, ymin + trozo_height\n            trozo = img.crop((xmin, ymin, xmax, ymax))\n            trozos.append(trozo)\n\n    return trozos\n\n\n# Para hacer esta prueba selecciono una imagen en especifico en onde se identifiquen claramente las caras de las personas\n\n# Imagen que se desea dividir\nimagen_crowd = Image.fromarray(df_crowd_pd['imagen'][5].astype('uint8'))\n\n# Tamaño de los trozos\ntamaño_trozos = (50, 50)\n\n# Obtiene los trozos de la imagen\ntrozos = dividir_imagen(imagen_crowd, tamaño_trozos)\n\n# Muestra cada trozo individualmente\nfor i, trozo in enumerate(trozos):\n    trozo.show()\n\n\nfilas = int(np.ceil(np.sqrt(len(trozos))))\ncolumnas = int(np.ceil(len(trozos) / filas))\n\n# Muestra todos los trozos en una sola imagen\nplt.figure(figsize=(10, 10))\n\nfor i, trozo in enumerate(trozos, 1):\n    plt.subplot(filas, columnas, i)\n    plt.imshow(np.array(trozo))\n    plt.axis('off')\n\nplt.show()\n\n\nimagen_crowd\n\n\n\n\n\n# Ahora aplico el modelo a cada trozo y se muestra el conteo de las personas localizadas\n\nfilas = int(np.ceil(np.sqrt(len(trozos))))\ncolumnas = int(np.ceil(len(trozos) / filas))\n\nplt.figure(figsize=(15, 15))\nfor i, trozo in enumerate(trozos, 1):\n    ax = plt.subplot(filas, columnas, i)\n    ev_modelo = model(trozo)\n    imprimir_objetos_multiple(trozo, ev_modelo)\n\nComo se puede apreciar no ha sido detectada ninguna persona. El problema puede venir de la calidad de la imagen. Para reducir el consumo de memoria las imagenes se importaron de forma automatica, sin especificar el tamaño, por lo que fueron reducidas a 256x256\nSe va a volver a realizar la prueba con otra foto de mayor calidad, tanto descargandola en 256x256 como en su resolución real\n\n# Imagen que se desea dividir\nimagen_crowd = Image.fromarray(df_crowd_pd['imagen'][7].astype('uint8'))\npersonas_real = number_list[7]\n\n# Tamaño de los trozos\ntamaño_trozos = (50, 50)\n\n# Obtiene los trozos de la imagen\ntrozos = dividir_imagen(imagen_crowd, tamaño_trozos)\n\n# Muestra cada trozo individualmente\nfor i, trozo in enumerate(trozos):\n    trozo.show()\n\n\nfilas = int(np.ceil(np.sqrt(len(trozos))))\ncolumnas = int(np.ceil(len(trozos) / filas))\n\n# Muestra todos los trozos en una sola imagen\nplt.figure(figsize=(10, 10))\n\nfor i, trozo in enumerate(trozos, 1):\n    plt.subplot(filas, columnas, i)\n    plt.imshow(np.array(trozo))\n    plt.axis('off')\n\nplt.show()\n\n\nimagen_crowd\n\n\n\n\n\nfilas = int(np.ceil(np.sqrt(len(trozos))))\ncolumnas = int(np.ceil(len(trozos) / filas))\n\npersonas_foto = 0\n\nplt.figure(figsize=(15, 15))\nfor i, trozo in enumerate(trozos, 1):\n    ax = plt.subplot(filas, columnas, i)\n    ev_modelo = model(trozo)\n    imprimir_objetos_multiple(trozo, ev_modelo)\n    personas_foto = personas_foto + cantidad_personas(ev_modelo)\n\nprint(f'El total calculado de personas en la imagen es: {personas_foto}')\nprint(f'El total real de personas en la imagen es: {personas_real}')\n\n\nimagen_tf = tf.keras.preprocessing.image.load_img('/content/gdrive/MyDrive/Colab Notebooks/ProyectoFinal/Crowd Counting/shanghaitech_with_people_density_map/ShanghaiTech/part_A/train_data/images/Crowd/IMG_105.jpg')\n\n\nimagen_np = tf.keras.preprocessing.image.img_to_array(imagen_tf)\n\n\n# Imagen que se desea dividir\nimagen_crowd = Image.fromarray(imagen_np.astype('uint8'))\nprint(imagen_crowd.size)\npersonas_real = number_list[7]\n\n# Tamaño de los trozos\ntamaño_trozos = (200, 200)\n\n# Obtiene los trozos de la imagen\ntrozos = dividir_imagen(imagen_crowd, tamaño_trozos)\n\n# Muestra cada trozo individualmente\nfor i, trozo in enumerate(trozos):\n    trozo.show()\n\n(990, 632)\n\n\n\nfilas = int(np.ceil(np.sqrt(len(trozos))))\ncolumnas = int(np.ceil(len(trozos) / filas))\n\npersonas_foto = 0\n\nplt.figure(figsize=(15,15))\nfor i, trozo in enumerate(trozos, 1):\n    ax = plt.subplot(3, 4, i)\n    ev_modelo = model(trozo)\n    imprimir_objetos_multiple(trozo, ev_modelo)\n    personas_foto = personas_foto + cantidad_personas(ev_modelo)\n\nprint(f'El total calculado de personas en la imagen es: {personas_foto}')\nprint(f'El total real de personas en la imagen es: {personas_real}')\n\n\n# Imagen que se desea dividir\nimagen_crowd = Image.fromarray(imagen_np.astype('uint8'))\nprint(imagen_crowd.size)\npersonas_real = number_list[7]\n\n# Tamaño de los trozos\ntamaño_trozos = (330, 126)\n\n# Obtiene los trozos de la imagen\ntrozos = dividir_imagen(imagen_crowd, tamaño_trozos)\n\n# Muestra cada trozo individualmente\nfor i, trozo in enumerate(trozos):\n    trozo.show()\n\n(990, 632)\n\n\n\nfilas = int(np.ceil(np.sqrt(len(trozos))))\ncolumnas = int(np.ceil(len(trozos) / filas))\n\npersonas_foto = 0\n\nplt.figure(figsize=(15,15))\nfor i, trozo in enumerate(trozos, 1):\n    ax = plt.subplot(5, 3, i)\n    ev_modelo = model(trozo)\n    imprimir_objetos_multiple(trozo, ev_modelo)\n    personas_foto = personas_foto + cantidad_personas(ev_modelo)\n\nprint(f'El total calculado de personas en la imagen es: {personas_foto}')\nprint(f'El total real de personas en la imagen es: {personas_real}')\n\nCon mejor resolución el resultado mejora considerablemente. Queda faltando entrenar el modulo con un dataset unicamente compuesto por personas, seguramente los resultados serian mucho mejores"
  },
  {
    "objectID": "data_analysis.html",
    "href": "data_analysis.html",
    "title": "Data analysis",
    "section": "",
    "text": "Why is Python so widely used in data analysis?\nThe rich ecosystem of libraries and tools specifically designed for data analysis is indeed the primary reason why Python is widely used in data analysis. Python’s popularity in this field is largely driven by the availability and quality of these libraries, which provide powerful and efficient solutions for various aspects of data manipulation, analysis, visualization, and machine learning.\nLibraries like NumPy, Pandas, Matplotlib, seaborn, scikit-learn, TensorFlow, and many others offer comprehensive functionalities that cover a wide range of data analysis tasks. These libraries are developed and maintained by dedicated teams of developers and have become essential tools for data analysts, scientists, and researchers worldwide."
  },
  {
    "objectID": "pandas.html",
    "href": "pandas.html",
    "title": "Pandas",
    "section": "",
    "text": "Pandas is a powerful and widely used open-source Python library for data manipulation and analysis. It provides easy-to-use data structures and functions to work with structured data, making it an essential tool for data scientists, analysts, and researchers.\nKey features of the Pandas library include:\n\nDataFrame: The primary data structure in Pandas is the DataFrame, which is a two-dimensional labeled data structure with columns of potentially different data types. It can be thought of as a spreadsheet or SQL table. DataFrames allow for easy manipulation and analysis of data, including filtering, sorting, grouping, and aggregation.\n\n\nimport pandas as pd\n\n# Creating a DataFrame from a dictionary\ndata = {'Name': ['Alice', 'Bob', 'Charlie', 'David'],\n        'Age': [25, 30, 35, 40],\n        'City': ['New York', 'Los Angeles', 'Chicago', 'Houston']}\ndf = pd.DataFrame(data)\nprint(df)\n\n      Name  Age         City\n0    Alice   25     New York\n1      Bob   30  Los Angeles\n2  Charlie   35      Chicago\n3    David   40      Houston\n\n\n\nReading Data from a File: Pandas can read data from various file formats such as CSV, Excel, JSON, SQL, and more.\n\n\n# Reading data from a CSV file\ndf = pd.read_csv('data.csv')\nprint(df.head())  # Print first few rows of the DataFrame\n\n\nBasic Data Manipulation: Pandas provides functions for data manipulation, including filtering, sorting, grouping, and aggregation.\n\n\n# Filtering rows based on a condition\nyoung_people = df[df['Age'] &lt; 30]\n\n# Sorting DataFrame by Age in descending order\ndf_sorted = df.sort_values(by='Age', ascending=False)\n\n# Grouping data by City and calculating average Age\navg_age_by_city = df.groupby('City')['Age'].mean()\n\n\nHandling Missing Values: Pandas provides functions to handle missing values, including checking for missing values, dropping rows with missing values, and filling missing values with a specified value.\n\n\n# Checking for missing values\nprint(df.isnull().sum())\n\n# Dropping rows with missing values\ndf_cleaned = df.dropna()\n\n# Filling missing values with a specified value\ndf_filled = df.fillna({'Age': df['Age'].mean()})\n\n\nExporting Data to a File: Pandas can export DataFrame to various file formats such as CSV, Excel, JSON, etc. python\n\n\n# Exporting DataFrame to a CSV file\ndf.to_csv('output.csv', index=False)\n\nOverall, Pandas is an essential tool for data analysis in Python, providing powerful data manipulation and analysis capabilities that streamline the process of working with structured data. Its intuitive syntax and extensive functionality make it a popular choice for data professionals."
  }
]